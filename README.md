# design_pattern
desgin pattern example
 # 单例模式
 ## 概念
 确保一个类只有一个实例，并提供全局访问点
 # 例子说明
 > single
  - 是双重锁定，通过同步synchronzed确保多线程下只被一个线程执行，并在在同步前后判空，确保不会重复实例化该类。
  - voliatile确保执行的顺序不会改变。jvm会对代码进行优化，当执行顺序是这样就会出现问题。1、分配内存-->2、把内存的引用赋值给instance-->3、再把实例化的对象初始化到该内存下。(事实不一定这样，可以当一个场景)<br>
    当线程A把2执行完，线程B判断instance是否为空，发现不为空，调用方法，这时就报nullpointException
 > static模式
  - 有人说这是饿汉模式，服务一启动就加载。
 > enum 
 - 枚举模式，好处：防止反射、反编译、返序列化、确保加载一个。在枚举初始化的时候实例化

# 策略模式
## 概念
策略模式： 定义了算法族，分别封装起来，让它们之间可以相互替换
## 优势
*   此模式让算法的变化独立于使用算法的客户
* 多用组合，少用继承
*  这个算法很常见，一个接口不同的实现就是策略模式啊

# 装饰者模式

## 概念
&emsp;&emsp; 动态地将责任附加到对象上。若要扩展功能，装饰者提供了
    比继承更有弹性的替代方案或者 **可以这样说包装对象**
 ## 优点:
 * CondimentDecorator继承Beverage，这是利用继承达到“类型匹配”
  而不是继承获得“行为”
 *  对扩展开放，对修改关闭
 
 ## 缺点
 * 当一个对象依赖特定的类型，然后忽然导入，导致错误。插入装饰者必须小心谨慎
 * 增加代码复杂度，使用者不知道到底导入了多少个装饰着
 * 装饰者导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂
 ## 例子
 >数据流
 #### 自己用过的例子
 > 真没有
 
  # 观察者模式
  ## 概念
 在对象之间定义一对多的依赖，这样依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新
  ## 例子说明
 天气展示栏，当天气有改变时，通知展示栏
 首先把多个展示栏注册到天气处理中心，当天气改变时，就遍历一个一个通知。<br>
 Subject、Observer、DisplayElement是接口
  > Subject 是一个对象，代表一种类型 <br>
  > Observer 是观察者，update方法<br>
  > DisplayElement 是展示栏
  
  > ### 共享session例子
  > 使用的就是java.util的observer。具体流程，每次请求封装session，请求结束后，判断session有没有改变，改变就更新redis的数据。
  
  # 适配器模式
  ## 概念
  &emsp;&emsp;将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间
  ## 例子
  比如服务提供一个接口是json格式，而需要的是String格式的。<br>
  再比如，业务需要一个接口有用户信息和部门节点的，而提供接口并没有。就需要开发一个接口，把用户信息接口与部门节点接口聚合
